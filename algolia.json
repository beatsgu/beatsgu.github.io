[
  {
    "objectID": "de66846db5926ce39ec2096679ab7a8750917c61",
    "permalink": "/post/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/",
    "title": "JavaScript基础知识点（二）：null、undefined、比较操作符与this讲解","content": " JavaScript基础知识点（二）：null、undefined、比较操作符与this讲解 1. 前言 在 JavaScript 基础知识点（一）中，我们了解了原始类型和对象类型（也称为基本数据类型和引用数据类型）。本文将深入探讨其中最容易混淆的概念：null 与 undefined 的区别、比较操作符的差异，以及 JavaScript 中最复杂的 this 指向问题。\nCSDN链接\n2. null 与 undefined 详解 首先明确一点：Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\n2.1 undefined：表示\u0026amp;quot;未定义\u0026amp;quot; 含义：表示\u0026amp;quot;未定义\u0026amp;quot;或\u0026amp;quot;缺少值\u0026amp;quot; 类型：undefined 类型 产生场景：变量声明但未赋值、函数没有返回值、访问不存在的属性等 特点：通常由 JavaScript 引擎自动产生 2.2 null：表示\u0026amp;quot;空值\u0026amp;quot; 含义：表示\u0026amp;quot;空\u0026amp;quot;或\u0026amp;quot;无\u0026amp;quot;，是一个明确的\u0026amp;quot;空值\u0026amp;quot; 类型：object 类型（这是一个历史bug，在第一篇中有详细讲解） 使用场景：开发者主动赋值，表示变量应该为空 特点：需要开发者主动设置 2.3 基本对比 // 基本类型检测 console.log(typeof undefined); // \u0026amp;#34;undefined\u0026amp;#34; console.log(typeof null); // \u0026amp;#34;object\u0026amp;#34; (历史bug) // 值比较 console.log(undefined == null); // true (会进行类型转换) console.log(undefined === null); // false (严格相等，类型不同) 2.4 产生 undefined 的常见场景 // 1. 声明变量但未赋值 let name; console.log(name); // undefined // 2. 函数参数未传递 function greet(name) { console.log(name); // undefined } greet(); // 3. …","date": "2025-08-27 14:00:00",
    "updated": "2025-08-27 14:00:00"
  }, 
  {
    "objectID": "ed1fdab4b626c10bd57d95330a5e8514082db36d",
    "permalink": "/post/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/",
    "title": "JavaScript基础知识点（一）：数据类型与内存管理","content": " JavaScript基础知识点（一）：数据类型与内存管理 1. 前言 理解 JavaScript 中的数据类型和内存管理是掌握这门语言的基础。本文将深入探讨原始类型与对象类型的区别，以及它们在内存中的不同存储方式。\nCSDN文章链接\n2. 数据类型的内存存储机制 在 JavaScript 中，数据类型分为两大类：原始类型和对象类型，它们有着截然不同的存储和访问方式。\n2.1 原始类型：值存储 原始类型包括：number、string、boolean、undefined、null、symbol、bigint\n特点：存储的是实际的值，直接保存在栈内存中。\nlet a = 10; let b = a; // b 得到的是 a 的值的副本 b = 20; console.log(a); // 10 (a 不会被影响) console.log(b); // 20 2.2 对象类型：引用存储 对象类型包括：Object、Array、Function、Date、RegExp 等\n特点：实际的值存储在堆内存中，变量中保存的是指向该堆内存地址的指针（引用）。\nlet obj1 = { name: \u0026amp;#34;张三\u0026amp;#34; }; let obj2 = obj1; // obj2 得到的是 obj1 的引用（指针） obj2.name = \u0026amp;#34;李四\u0026amp;#34;; console.log(obj1.name); // \u0026amp;#34;李四\u0026amp;#34; (obj1 也被修改了) console.log(obj2.name); // \u0026amp;#34;李四\u0026amp;#34; 2.3 内存模型详解 对于上面的例子，内存分配如下：\n变量 obj1 存储了内存地址 #001 在地址 #001 的位置存放了值 { name: \u0026amp;quot;张三\u0026amp;quot; } 当执行 obj2 = obj1 时，复制的是地址 #001 两个变量都指向同一块内存空间，修改任一变量都会影响另一个 3. 经典案例：函数参数传递 让我们通过一个经典案例来加深理解：\nfunction test(person) { person.age = 26; // 修改对象属性 person = { // 重新赋值 name: \u0026amp;#39;yyy\u0026amp;#39;, age: 30 }; return person; } const p1 = { name: …","date": "2025-08-26 11:00:00",
    "updated": "2025-08-26 11:00:00"
  }, 
  {
    "objectID": "c54b4c52449ac3c45778bfac7ae1b6ae9d76c6a2",
    "permalink": "/post/android-compose-ui%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8D%97%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/",
    "title": "Android Compose UI设计实现指南：样式设置最佳实践","content": " Android Compose UI设计实现指南：样式设置最佳实践 在Android Jetpack Compose开发中，正确设置组件样式是实现精美UI的关键。本文将通过实际案例，分享各类组件的样式设置最佳实践和常见技巧。\ncsdn文章链接\n1. Card组件样式设置 背景颜色设置 ❌ 不推荐的写法：\nCard( modifier = Modifier.background(Color(0xFFFAFAFA)) ) { ... } ✅ 推荐的写法：\nCard( colors = CardDefaults.cardColors(containerColor = Color(0xFFFAFAFA)), elevation = CardDefaults.cardElevation(defaultElevation = 4.dp), shape = RoundedCornerShape(8.dp) ) { ... } 完整的Card样式配置 Card( modifier = Modifier.fillMaxWidth(), elevation = CardDefaults.cardElevation(defaultElevation = 4.dp), shape = RoundedCornerShape(8.dp), colors = CardDefaults.cardColors( containerColor = Color(0xFFFAFAFA), contentColor = MaterialTheme.colorScheme.onSurface ) ) { // Card内容 } 关键点：\n使用CardDefaults.cardColors()而不是background() containerColor设置Card背景色 contentColor设置Card内容的默认颜色 elevation控制阴影效果 2. Button组件样式定制 状态驱动的Button样式 Button( onClick = { selectedModel = model }, modifier = Modifier .weight(1f) .height(32.dp), contentPadding = PaddingValues(horizontal = 12.dp, …","date": "2025-08-24 11:00:00",
    "updated": "2025-08-25 11:00:00"
  }, 
  {
    "objectID": "0b7c0f017d15c5b41ce2b823431843577c58cef3",
    "permalink": "/post/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/",
    "title": "Java并发编程","content": " Java并发编程 进程 程序是静态的，进程可以看作是程序的一个实例。\n二者对比 进程是相互独立的，线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间，供其内部的线程共享。 进程间通信较为复杂 同一台计算机的进程通信称为 IPC 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP 线程通信相对简单，因为它们共享进程内的内存。 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。 ​\t单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 ​ 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】） 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 ​ IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化 创建和运行线程 方法一 直接使用Thread Thread t = new Thread() { @Override public void run() { // 要执行的任务 } } // 启动线程 t.start() 方法二 使用Runnable配合Thread 把线程和任务分开\nThread代表线程 Runnable代表可运行的任务（线程要执行的代码） Runnable runnable = new Runnable() { public void run(){ // 要执行的任务 } }; // 创建线程对象 Thread t = new Thread( runnable ); // 启动线程 t.start(); Java8 之后可以使用lambda精简代码\n// 创建任务对象 Runnable task2 = () -\u0026amp;gt; log.debug(\u0026amp;#34;hello\u0026amp;#34;); // 参数1 是任务对象; 参数2 是线程名字，推荐 Thread t2 = new Thread(task2, …","date": "2025-08-20 11:00:00",
    "updated": "2025-08-21 11:00:00"
  }, 
  {
    "objectID": "5f98474743e52347613b2e0c682fa859935c78fa",
    "permalink": "/post/hello/",
    "title": "Hello World","content": "天下无敌，天上来敌\n","date": "2023-03-15 11:00:00",
    "updated": "2023-03-15 11:00:00"
  }, 
  {
    "objectID": "712c2bc9e13ff43d5d2d5f0c370c4876ac495e3e",
    "permalink": "/post/markdown%E4%BD%BF%E7%94%A8%E8%AE%B2%E8%A7%A3/",
    "title": "Markdown使用讲解","content": " Markdown使用讲解 Markdown语法速查表\nMarkdown基本语法\nMarkdown扩展语法\nCSDN文章链接\n1.标题 Markdown支持6级标题，使用#符号表示：\n# 一级标题（#） ## 二级标题（##） ### 三级标题（###） #### 四级标题（####） ##### 五级标题（#####） ###### 六级标题（######） 2.引用 使用\u0026amp;gt;表示引用：\n这是一段引用\n这是嵌套引用\n\u0026amp;gt; 这是一段引用 \u0026amp;gt; \u0026amp;gt; \u0026amp;gt; 这是嵌套引用 3.列表 有序列表 使用数字加点号：\n打开冰箱 把大象放进去 关上冰箱 1. 打开冰箱 2. 把大象放进去 3. 关上冰箱 无序列表 可以使用*、-或+：\n使用星号（*）\n第二项\n使用短横线（-）\n第二项\n使用加号（+）\n第二项\n任务列表 已完成的任务 未完成的任务 另一个未完成的任务 - [x] 已完成的任务 - [ ] 未完成的任务 - [ ] 另一个未完成的任务 注意：要一整行打完要回车才能正确显示 4.代码 行内代码 使用反引号包围：console.log(\u0026amp;quot;Hello World\u0026amp;quot;)\n`console.log(\u0026amp;#34;Hello World\u0026amp;#34;)` 代码块 使用三个反引号，可指定语言：\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026amp;#34;Hello, World!\u0026amp;#34;); } } ```java public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026amp;#34;Hello, World!\u0026amp;#34;); } } ``` 5.数学公式 块级公式 使用双美元符号： $$ \\frac{\\partial f}{\\partial x} = 2\\sqrt{a}x $$\n块级： $$ \\frac{\\partial f}{\\partial x} = 2\\sqrt{a}x $$ 6.表格 姓名 年龄 成绩 备注 张三 18 95 优秀 李四 19 87 良好 王五 20 92 …","date": "2023-03-15 11:00:00",
    "updated": "2023-03-15 11:00:00"
  }]